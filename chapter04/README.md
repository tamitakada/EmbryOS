# Chapter 04: Interrupts and Preemption

A CPU alternates between running kernel code and application code.  So far, we
have relied on applications to give control back to the kernel by invoking
system calls.  In a practical operating system, the kernel needs to obtain
control back periodically even if an application is fully CPU-bound.

## Learning Objectives

- Transition from cooperative to preemptive multitasking, where processes context switch on timer interrupts.
- Understand how periodic interrupts are generated by the RISCâ€“V machine timer.
- Learn how priority levels determine which process runs next.
- Explore how the idle loop operates at the lowest priority, waiting for interrupts.
- Observe how the kernel safely enables and disables interrupts around scheduling operations.

## New or Modified Modules

| File | Purpose |
|------|---------|
| `hello.c` | Defines exception and timer interrupt handlers and sets up periodic timer interrupts. |
| `sched.[ch]`, `sched2.c` | Prioritized scheduling |
| `interrupt.[ch]` | Interrupt handling |
| `sbi.[Sh]` | Time and Timers |
| `trap.[Sh]` | Trap vector and Trap Frames |

## Key Functions & Symbols

| Name | Description |
|------|-------------|
| `struct pcb *run_queue[3]` | run queue for each of 3 priority levels |
| `uint64_t time_base` | contains the number of clock ticks per second |
| `void intr_init(void)` | Initialization of CPU interrupt state |
| `uint32_t fdt_get_timebase(void)` | Retrieves how fast the CPU clock runs |
| `void sbi_set_time(when)` | Schedules the next timer interrupt |
| `uint64_t mtime_get()` | return the number of clock ticks since boot |
| `void enter_user(app)` | Invokes application `app` with interrupts enabled |
| `void trap_wfi(block)` | Waits for the next interrupt and invokes `software_trap_handler()` with a pointer to the trap frame |

## Discussion

Interrupts are central to any operating system.  There are two flavors:
device interrupts (which include timers) and exceptions (directly caused by
a process, such as divide by zero).  Device interrupts can be masked, while
exceptions cannot.  The EmbryOS kernel masks device interrupts while it is
executing, but enables them while user code is running.

Timer interrupts are used to ensure that user code periodically passes control
back to the kernel.  This way the kernel can multiplex multiple processes on
the CPU without the processes explicitly cooperating by calling system calls
such as `user_yield()`.

EmbryOS now supports three levels of priority.
Interactive processes run at priority 0, the highest priority.
When a process is interrupted by a timer interrupt it automatically
calls `user_yield()`, which moves the process to priority 1.
The idle loop, invoked by the first process, runs at priority 2.
The idle loop uses the RISC-V `wfi` instruction to wait for an interrupt,
reducing power consumption.

Unfortunately, not all platforms support interrupts.  EmbryOS is capable of
running on such platforms, but does not use `wfi` in that case so it does
not wait indefinitely.

## Check the Log

Run EmbryOS and extract the log as before.  You will
now find `TRAP` events like the following:

```
[7,47,54302] TRAP scause:'Supervisor timer interrupt' sepc:0x80204834 stval:0x0 self:0x80520000
[7,47,54303] CTX_SWITCH old:0x80520000 new:0x80524000 hart:3
```

You see here a timer interrupt followed by a context switch, which is process preemption in action!
In this case, there is a switch from process `0x80520000` (the address of the process control block of that process) to process `0x80524000`.

## ðŸ’¬ Ask Your LLM

- How does the hardware timer cause the kernel to preempt a running process?
- Why must the idle loop briefly enable interrupts before calling wfi?
- What advantages do priority levels provide compared with a single run queue?
- How does sbi_set_timer() relate to mtime_get()?

## Exercises

- Create a system call to retrieve the time and another to sleep for a
certain amount of time.
- Create a clock application that shows how many seconds have expired since
  the kernel was booted.
